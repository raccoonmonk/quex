# Project Quex (http://quex.sourceforge.net); License: MIT;
# (C) 2005-2020 Frank-Rene Schaefer; 
import quex.engine.misc.error              as     error
from   quex.engine.misc.unistream          import UniStream
from   quex.engine.misc.interval_handling  import NumberSet

import os

__reference_to_setup = None
def specify_setup_object(TheSetup):
    global __reference_to_setup 
    __reference_to_setup = TheSetup
    error.specify_setup_object(TheSetup)

class EndOfStreamException(Exception):
    pass

temporary_files = []

def skip_whitespace(fh, ExceptNewlineF=False):
    def __skip_until_newline(fh):
        tmp = "X" # something not ""
        while tmp and tmp != '\n':
            tmp = fh.read(1)

    def __skip_until_end_of_comment(fh):
        previous = " "
        while 1 + 1 == 2:
            tmp = fh.read(1)
            if   not tmp:                        return
            elif previous == "*" and tmp == "/": return
            previous = tmp

    while 1 + 1 == 2:
        pos = fh.tell()
        tmp = fh.read(1)
        if   ExceptNewlineF and tmp == "\n": fh.seek(pos); return
        elif tmp.isspace():                  continue
        elif tmp != "/":                     fh.seek(pos); return
        elif not tmp:                        return

        # Comment starting with '/'?
        tmp = fh.read(1)
        if   tmp == "/": __skip_until_newline(fh)        # '//' ... newline
        elif tmp == "*": __skip_until_end_of_comment(fh) # '/*' ... '*/'
        else:            fh.seek(pos); return            # no comment => return

__id_start = NumberSet.from_tuples([(0x41,0x5B), (0x5F,0x60), (0x61,0x7B), (0xAA,0xAB), (0xB5,0xB6), (0xBA,0xBB), (0xC0,0xD7), (0xD8,0xF7), (0xF8,0x02C2), (0x02C6,0x02D2), (0x02E0,0x02E5), (0x02EC,0x02ED), (0x02EE,0x02EF), (0x0370,0x0375), (0x0376,0x0378), (0x037A,0x037E), (0x037F,0x0380), (0x0386,0x0387), (0x0388,0x038B), (0x038C,0x038D), (0x038E,0x03A2), (0x03A3,0x03F6), (0x03F7,0x0482), (0x048A,0x0530), (0x0531,0x0557), (0x0559,0x055A), (0x0561,0x0588), (0x05D0,0x05EB), (0x05F0,0x05F3), (0x0620,0x064B), (0x066E,0x0670), (0x0671,0x06D4), (0x06D5,0x06D6), (0x06E5,0x06E7), (0x06EE,0x06F0), (0x06FA,0x06FD), (0x06FF,0x0700), (0x0710,0x0711), (0x0712,0x0730), (0x074D,0x07A6), (0x07B1,0x07B2), (0x07CA,0x07EB), (0x07F4,0x07F6), (0x07FA,0x07FB), (0x0800,0x0816), (0x081A,0x081B), (0x0824,0x0825), (0x0828,0x0829), (0x0840,0x0859), (0x08A0,0x08B5), (0x0904,0x093A), (0x093D,0x093E), (0x0950,0x0951), (0x0958,0x0962), (0x0971,0x0981), (0x0985,0x098D), (0x098F,0x0991), (0x0993,0x09A9), (0x09AA,0x09B1), (0x09B2,0x09B3), (0x09B6,0x09BA), (0x09BD,0x09BE), (0x09CE,0x09CF), (0x09DC,0x09DE), (0x09DF,0x09E2), (0x09F0,0x09F2), (0x0A05,0x0A0B), (0x0A0F,0x0A11), (0x0A13,0x0A29), (0x0A2A,0x0A31), (0x0A32,0x0A34), (0x0A35,0x0A37), (0x0A38,0x0A3A), (0x0A59,0x0A5D), (0x0A5E,0x0A5F), (0x0A72,0x0A75), (0x0A85,0x0A8E), (0x0A8F,0x0A92), (0x0A93,0x0AA9), (0x0AAA,0x0AB1), (0x0AB2,0x0AB4), (0x0AB5,0x0ABA), (0x0ABD,0x0ABE), (0x0AD0,0x0AD1), (0x0AE0,0x0AE2), (0x0AF9,0x0AFA), (0x0B05,0x0B0D), (0x0B0F,0x0B11), (0x0B13,0x0B29), (0x0B2A,0x0B31), (0x0B32,0x0B34), (0x0B35,0x0B3A), (0x0B3D,0x0B3E), (0x0B5C,0x0B5E), (0x0B5F,0x0B62), (0x0B71,0x0B72), (0x0B83,0x0B84), (0x0B85,0x0B8B), (0x0B8E,0x0B91), (0x0B92,0x0B96), (0x0B99,0x0B9B), (0x0B9C,0x0B9D), (0x0B9E,0x0BA0), (0x0BA3,0x0BA5), (0x0BA8,0x0BAB), (0x0BAE,0x0BBA), (0x0BD0,0x0BD1), (0x0C05,0x0C0D), (0x0C0E,0x0C11), (0x0C12,0x0C29), (0x0C2A,0x0C3A), (0x0C3D,0x0C3E), (0x0C58,0x0C5B), (0x0C60,0x0C62), (0x0C85,0x0C8D), (0x0C8E,0x0C91), (0x0C92,0x0CA9), (0x0CAA,0x0CB4), (0x0CB5,0x0CBA), (0x0CBD,0x0CBE), (0x0CDE,0x0CDF), (0x0CE0,0x0CE2), (0x0CF1,0x0CF3), (0x0D05,0x0D0D), (0x0D0E,0x0D11), (0x0D12,0x0D3B), (0x0D3D,0x0D3E), (0x0D4E,0x0D4F), (0x0D5F,0x0D62), (0x0D7A,0x0D80), (0x0D85,0x0D97), (0x0D9A,0x0DB2), (0x0DB3,0x0DBC), (0x0DBD,0x0DBE), (0x0DC0,0x0DC7), (0x0E01,0x0E31), (0x0E32,0x0E34), (0x0E40,0x0E47), (0x0E81,0x0E83), (0x0E84,0x0E85), (0x0E87,0x0E89), (0x0E8A,0x0E8B), (0x0E8D,0x0E8E), (0x0E94,0x0E98), (0x0E99,0x0EA0), (0x0EA1,0x0EA4), (0x0EA5,0x0EA6), (0x0EA7,0x0EA8), (0x0EAA,0x0EAC), (0x0EAD,0x0EB1), (0x0EB2,0x0EB4), (0x0EBD,0x0EBE), (0x0EC0,0x0EC5), (0x0EC6,0x0EC7), (0x0EDC,0x0EE0), (0x0F00,0x0F01), (0x0F40,0x0F48), (0x0F49,0x0F6D), (0x0F88,0x0F8D), (0x1000,0x102B), (0x103F,0x1040), (0x1050,0x1056), (0x105A,0x105E), (0x1061,0x1062), (0x1065,0x1067), (0x106E,0x1071), (0x1075,0x1082), (0x108E,0x108F), (0x10A0,0x10C6), (0x10C7,0x10C8), (0x10CD,0x10CE), (0x10D0,0x10FB), (0x10FC,0x1249), (0x124A,0x124E), (0x1250,0x1257), (0x1258,0x1259), (0x125A,0x125E), (0x1260,0x1289), (0x128A,0x128E), (0x1290,0x12B1), (0x12B2,0x12B6), (0x12B8,0x12BF), (0x12C0,0x12C1), (0x12C2,0x12C6), (0x12C8,0x12D7), (0x12D8,0x1311), (0x1312,0x1316), (0x1318,0x135B), (0x1380,0x1390), (0x13A0,0x13F6), (0x13F8,0x13FE), (0x1401,0x166D), (0x166F,0x1680), (0x1681,0x169B), (0x16A0,0x16EB), (0x16EE,0x16F9), (0x1700,0x170D), (0x170E,0x1712), (0x1720,0x1732), (0x1740,0x1752), (0x1760,0x176D), (0x176E,0x1771), (0x1780,0x17B4), (0x17D7,0x17D8), (0x17DC,0x17DD), (0x1820,0x1878), (0x1880,0x18A9), (0x18AA,0x18AB), (0x18B0,0x18F6), (0x1900,0x191F), (0x1950,0x196E), (0x1970,0x1975), (0x1980,0x19AC), (0x19B0,0x19CA), (0x1A00,0x1A17), (0x1A20,0x1A55), (0x1AA7,0x1AA8), (0x1B05,0x1B34), (0x1B45,0x1B4C), (0x1B83,0x1BA1), (0x1BAE,0x1BB0), (0x1BBA,0x1BE6), (0x1C00,0x1C24), (0x1C4D,0x1C50), (0x1C5A,0x1C7E), (0x1CE9,0x1CED), (0x1CEE,0x1CF2), (0x1CF5,0x1CF7), (0x1D00,0x1DC0), (0x1E00,0x1F16), (0x1F18,0x1F1E), (0x1F20,0x1F46), (0x1F48,0x1F4E), (0x1F50,0x1F58), (0x1F59,0x1F5A), (0x1F5B,0x1F5C), (0x1F5D,0x1F5E), (0x1F5F,0x1F7E), (0x1F80,0x1FB5), (0x1FB6,0x1FBD), (0x1FBE,0x1FBF), (0x1FC2,0x1FC5), (0x1FC6,0x1FCD), (0x1FD0,0x1FD4), (0x1FD6,0x1FDC), (0x1FE0,0x1FED), (0x1FF2,0x1FF5), (0x1FF6,0x1FFD), (0x2071,0x2072), (0x207F,0x2080), (0x2090,0x209D), (0x2102,0x2103), (0x2107,0x2108), (0x210A,0x2114), (0x2115,0x2116), (0x2118,0x211E), (0x2124,0x2125), (0x2126,0x2127), (0x2128,0x2129), (0x212A,0x213A), (0x213C,0x2140), (0x2145,0x214A), (0x214E,0x214F), (0x2160,0x2189), (0x2C00,0x2C2F), (0x2C30,0x2C5F), (0x2C60,0x2CE5), (0x2CEB,0x2CEF), (0x2CF2,0x2CF4), (0x2D00,0x2D26), (0x2D27,0x2D28), (0x2D2D,0x2D2E), (0x2D30,0x2D68), (0x2D6F,0x2D70), (0x2D80,0x2D97), (0x2DA0,0x2DA7), (0x2DA8,0x2DAF), (0x2DB0,0x2DB7), (0x2DB8,0x2DBF), (0x2DC0,0x2DC7), (0x2DC8,0x2DCF), (0x2DD0,0x2DD7), (0x2DD8,0x2DDF), (0x3005,0x3008), (0x3021,0x302A), (0x3031,0x3036), (0x3038,0x303D), (0x3041,0x3097), (0x309B,0x30A0), (0x30A1,0x30FB), (0x30FC,0x3100), (0x3105,0x312E), (0x3131,0x318F), (0x31A0,0x31BB), (0x31F0,0x3200), (0x3400,0x4DB6), (0x4E00,0x9FD6), (0xA000,0xA48D), (0xA4D0,0xA4FE), (0xA500,0xA60D), (0xA610,0xA620), (0xA62A,0xA62C), (0xA640,0xA66F), (0xA67F,0xA69E), (0xA6A0,0xA6F0), (0xA717,0xA720), (0xA722,0xA789), (0xA78B,0xA7AE), (0xA7B0,0xA7B8), (0xA7F7,0xA802), (0xA803,0xA806), (0xA807,0xA80B), (0xA80C,0xA823), (0xA840,0xA874), (0xA882,0xA8B4), (0xA8F2,0xA8F8), (0xA8FB,0xA8FC), (0xA8FD,0xA8FE), (0xA90A,0xA926), (0xA930,0xA947), (0xA960,0xA97D), (0xA984,0xA9B3), (0xA9CF,0xA9D0), (0xA9E0,0xA9E5), (0xA9E6,0xA9F0), (0xA9FA,0xA9FF), (0xAA00,0xAA29), (0xAA40,0xAA43), (0xAA44,0xAA4C), (0xAA60,0xAA77), (0xAA7A,0xAA7B), (0xAA7E,0xAAB0), (0xAAB1,0xAAB2), (0xAAB5,0xAAB7), (0xAAB9,0xAABE), (0xAAC0,0xAAC1), (0xAAC2,0xAAC3), (0xAADB,0xAADE), (0xAAE0,0xAAEB), (0xAAF2,0xAAF5), (0xAB01,0xAB07), (0xAB09,0xAB0F), (0xAB11,0xAB17), (0xAB20,0xAB27), (0xAB28,0xAB2F), (0xAB30,0xAB5B), (0xAB5C,0xAB66), (0xAB70,0xABE3), (0xAC00,0xD7A4), (0xD7B0,0xD7C7), (0xD7CB,0xD7FC), (0xF900,0xFA6E), (0xFA70,0xFADA), (0xFB00,0xFB07), (0xFB13,0xFB18), (0xFB1D,0xFB1E), (0xFB1F,0xFB29), (0xFB2A,0xFB37), (0xFB38,0xFB3D), (0xFB3E,0xFB3F), (0xFB40,0xFB42), (0xFB43,0xFB45), (0xFB46,0xFBB2), (0xFBD3,0xFD3E), (0xFD50,0xFD90), (0xFD92,0xFDC8), (0xFDF0,0xFDFC), (0xFE70,0xFE75), (0xFE76,0xFEFD), (0xFF21,0xFF3B), (0xFF41,0xFF5B), (0xFF66,0xFFBF), (0xFFC2,0xFFC8), (0xFFCA,0xFFD0), (0xFFD2,0xFFD8), (0xFFDA,0xFFDD), (0x10000,0x1000C), (0x1000D,0x10027), (0x10028,0x1003B), (0x1003C,0x1003E), (0x1003F,0x1004E), (0x10050,0x1005E), (0x10080,0x100FB), (0x10140,0x10175), (0x10280,0x1029D), (0x102A0,0x102D1), (0x10300,0x10320), (0x10330,0x1034B), (0x10350,0x10376), (0x10380,0x1039E), (0x103A0,0x103C4), (0x103C8,0x103D0), (0x103D1,0x103D6), (0x10400,0x1049E), (0x10500,0x10528), (0x10530,0x10564), (0x10600,0x10737), (0x10740,0x10756), (0x10760,0x10768), (0x10800,0x10806), (0x10808,0x10809), (0x1080A,0x10836), (0x10837,0x10839), (0x1083C,0x1083D), (0x1083F,0x10856), (0x10860,0x10877), (0x10880,0x1089F), (0x108E0,0x108F3), (0x108F4,0x108F6), (0x10900,0x10916), (0x10920,0x1093A), (0x10980,0x109B8), (0x109BE,0x109C0), (0x10A00,0x10A01), (0x10A10,0x10A14), (0x10A15,0x10A18), (0x10A19,0x10A34), (0x10A60,0x10A7D), (0x10A80,0x10A9D), (0x10AC0,0x10AC8), (0x10AC9,0x10AE5), (0x10B00,0x10B36), (0x10B40,0x10B56), (0x10B60,0x10B73), (0x10B80,0x10B92), (0x10C00,0x10C49), (0x10C80,0x10CB3), (0x10CC0,0x10CF3), (0x11003,0x11038), (0x11083,0x110B0), (0x110D0,0x110E9), (0x11103,0x11127), (0x11150,0x11173), (0x11176,0x11177), (0x11183,0x111B3), (0x111C1,0x111C5), (0x111DA,0x111DB), (0x111DC,0x111DD), (0x11200,0x11212), (0x11213,0x1122C), (0x11280,0x11287), (0x11288,0x11289), (0x1128A,0x1128E), (0x1128F,0x1129E), (0x1129F,0x112A9), (0x112B0,0x112DF), (0x11305,0x1130D), (0x1130F,0x11311), (0x11313,0x11329), (0x1132A,0x11331), (0x11332,0x11334), (0x11335,0x1133A), (0x1133D,0x1133E), (0x11350,0x11351), (0x1135D,0x11362), (0x11480,0x114B0), (0x114C4,0x114C6), (0x114C7,0x114C8), (0x11580,0x115AF), (0x115D8,0x115DC), (0x11600,0x11630), (0x11644,0x11645), (0x11680,0x116AB), (0x11700,0x1171A), (0x118A0,0x118E0), (0x118FF,0x11900), (0x11AC0,0x11AF9), (0x12000,0x1239A), (0x12400,0x1246F), (0x12480,0x12544), (0x13000,0x1342F), (0x14400,0x14647), (0x16800,0x16A39), (0x16A40,0x16A5F), (0x16AD0,0x16AEE), (0x16B00,0x16B30), (0x16B40,0x16B44), (0x16B63,0x16B78), (0x16B7D,0x16B90), (0x16F00,0x16F45), (0x16F50,0x16F51), (0x16F93,0x16FA0), (0x1B000,0x1B002), (0x1BC00,0x1BC6B), (0x1BC70,0x1BC7D), (0x1BC80,0x1BC89), (0x1BC90,0x1BC9A), (0x1D400,0x1D455), (0x1D456,0x1D49D), (0x1D49E,0x1D4A0), (0x1D4A2,0x1D4A3), (0x1D4A5,0x1D4A7), (0x1D4A9,0x1D4AD), (0x1D4AE,0x1D4BA), (0x1D4BB,0x1D4BC), (0x1D4BD,0x1D4C4), (0x1D4C5,0x1D506), (0x1D507,0x1D50B), (0x1D50D,0x1D515), (0x1D516,0x1D51D), (0x1D51E,0x1D53A), (0x1D53B,0x1D53F), (0x1D540,0x1D545), (0x1D546,0x1D547), (0x1D54A,0x1D551), (0x1D552,0x1D6A6), (0x1D6A8,0x1D6C1), (0x1D6C2,0x1D6DB), (0x1D6DC,0x1D6FB), (0x1D6FC,0x1D715), (0x1D716,0x1D735), (0x1D736,0x1D74F), (0x1D750,0x1D76F), (0x1D770,0x1D789), (0x1D78A,0x1D7A9), (0x1D7AA,0x1D7C3), (0x1D7C4,0x1D7CC), (0x1E800,0x1E8C5), (0x1EE00,0x1EE04), (0x1EE05,0x1EE20), (0x1EE21,0x1EE23), (0x1EE24,0x1EE25), (0x1EE27,0x1EE28), (0x1EE29,0x1EE33), (0x1EE34,0x1EE38), (0x1EE39,0x1EE3A), (0x1EE3B,0x1EE3C), (0x1EE42,0x1EE43), (0x1EE47,0x1EE48), (0x1EE49,0x1EE4A), (0x1EE4B,0x1EE4C), (0x1EE4D,0x1EE50), (0x1EE51,0x1EE53), (0x1EE54,0x1EE55), (0x1EE57,0x1EE58), (0x1EE59,0x1EE5A), (0x1EE5B,0x1EE5C), (0x1EE5D,0x1EE5E), (0x1EE5F,0x1EE60), (0x1EE61,0x1EE63), (0x1EE64,0x1EE65), (0x1EE67,0x1EE6B), (0x1EE6C,0x1EE73), (0x1EE74,0x1EE78), (0x1EE79,0x1EE7D), (0x1EE7E,0x1EE7F), (0x1EE80,0x1EE8A), (0x1EE8B,0x1EE9C), (0x1EEA1,0x1EEA4), (0x1EEA5,0x1EEAA), (0x1EEAB,0x1EEBC), (0x20000,0x2A6D7), (0x2A700,0x2B735), (0x2B740,0x2B81E), (0x2B820,0x2CEA2), (0x2F800,0x2FA1E)])
__id_continue = NumberSet.from_tuples([(0x30,0x3A), (0x41,0x5B), (0x5F,0x60), (0x61,0x7B), (0xAA,0xAB), (0xB5,0xB6), (0xB7,0xB8), (0xBA,0xBB), (0xC0,0xD7), (0xD8,0xF7), (0xF8,0x02C2), (0x02C6,0x02D2), (0x02E0,0x02E5), (0x02EC,0x02ED), (0x02EE,0x02EF), (0x0300,0x0375), (0x0376,0x0378), (0x037A,0x037E), (0x037F,0x0380), (0x0386,0x038B), (0x038C,0x038D), (0x038E,0x03A2), (0x03A3,0x03F6), (0x03F7,0x0482), (0x0483,0x0488), (0x048A,0x0530), (0x0531,0x0557), (0x0559,0x055A), (0x0561,0x0588), (0x0591,0x05BE), (0x05BF,0x05C0), (0x05C1,0x05C3), (0x05C4,0x05C6), (0x05C7,0x05C8), (0x05D0,0x05EB), (0x05F0,0x05F3), (0x0610,0x061B), (0x0620,0x066A), (0x066E,0x06D4), (0x06D5,0x06DD), (0x06DF,0x06E9), (0x06EA,0x06FD), (0x06FF,0x0700), (0x0710,0x074B), (0x074D,0x07B2), (0x07C0,0x07F6), (0x07FA,0x07FB), (0x0800,0x082E), (0x0840,0x085C), (0x08A0,0x08B5), (0x08E3,0x0964), (0x0966,0x0970), (0x0971,0x0984), (0x0985,0x098D), (0x098F,0x0991), (0x0993,0x09A9), (0x09AA,0x09B1), (0x09B2,0x09B3), (0x09B6,0x09BA), (0x09BC,0x09C5), (0x09C7,0x09C9), (0x09CB,0x09CF), (0x09D7,0x09D8), (0x09DC,0x09DE), (0x09DF,0x09E4), (0x09E6,0x09F2), (0x0A01,0x0A04), (0x0A05,0x0A0B), (0x0A0F,0x0A11), (0x0A13,0x0A29), (0x0A2A,0x0A31), (0x0A32,0x0A34), (0x0A35,0x0A37), (0x0A38,0x0A3A), (0x0A3C,0x0A3D), (0x0A3E,0x0A43), (0x0A47,0x0A49), (0x0A4B,0x0A4E), (0x0A51,0x0A52), (0x0A59,0x0A5D), (0x0A5E,0x0A5F), (0x0A66,0x0A76), (0x0A81,0x0A84), (0x0A85,0x0A8E), (0x0A8F,0x0A92), (0x0A93,0x0AA9), (0x0AAA,0x0AB1), (0x0AB2,0x0AB4), (0x0AB5,0x0ABA), (0x0ABC,0x0AC6), (0x0AC7,0x0ACA), (0x0ACB,0x0ACE), (0x0AD0,0x0AD1), (0x0AE0,0x0AE4), (0x0AE6,0x0AF0), (0x0AF9,0x0AFA), (0x0B01,0x0B04), (0x0B05,0x0B0D), (0x0B0F,0x0B11), (0x0B13,0x0B29), (0x0B2A,0x0B31), (0x0B32,0x0B34), (0x0B35,0x0B3A), (0x0B3C,0x0B45), (0x0B47,0x0B49), (0x0B4B,0x0B4E), (0x0B56,0x0B58), (0x0B5C,0x0B5E), (0x0B5F,0x0B64), (0x0B66,0x0B70), (0x0B71,0x0B72), (0x0B82,0x0B84), (0x0B85,0x0B8B), (0x0B8E,0x0B91), (0x0B92,0x0B96), (0x0B99,0x0B9B), (0x0B9C,0x0B9D), (0x0B9E,0x0BA0), (0x0BA3,0x0BA5), (0x0BA8,0x0BAB), (0x0BAE,0x0BBA), (0x0BBE,0x0BC3), (0x0BC6,0x0BC9), (0x0BCA,0x0BCE), (0x0BD0,0x0BD1), (0x0BD7,0x0BD8), (0x0BE6,0x0BF0), (0x0C00,0x0C04), (0x0C05,0x0C0D), (0x0C0E,0x0C11), (0x0C12,0x0C29), (0x0C2A,0x0C3A), (0x0C3D,0x0C45), (0x0C46,0x0C49), (0x0C4A,0x0C4E), (0x0C55,0x0C57), (0x0C58,0x0C5B), (0x0C60,0x0C64), (0x0C66,0x0C70), (0x0C81,0x0C84), (0x0C85,0x0C8D), (0x0C8E,0x0C91), (0x0C92,0x0CA9), (0x0CAA,0x0CB4), (0x0CB5,0x0CBA), (0x0CBC,0x0CC5), (0x0CC6,0x0CC9), (0x0CCA,0x0CCE), (0x0CD5,0x0CD7), (0x0CDE,0x0CDF), (0x0CE0,0x0CE4), (0x0CE6,0x0CF0), (0x0CF1,0x0CF3), (0x0D01,0x0D04), (0x0D05,0x0D0D), (0x0D0E,0x0D11), (0x0D12,0x0D3B), (0x0D3D,0x0D45), (0x0D46,0x0D49), (0x0D4A,0x0D4F), (0x0D57,0x0D58), (0x0D5F,0x0D64), (0x0D66,0x0D70), (0x0D7A,0x0D80), (0x0D82,0x0D84), (0x0D85,0x0D97), (0x0D9A,0x0DB2), (0x0DB3,0x0DBC), (0x0DBD,0x0DBE), (0x0DC0,0x0DC7), (0x0DCA,0x0DCB), (0x0DCF,0x0DD5), (0x0DD6,0x0DD7), (0x0DD8,0x0DE0), (0x0DE6,0x0DF0), (0x0DF2,0x0DF4), (0x0E01,0x0E3B), (0x0E40,0x0E4F), (0x0E50,0x0E5A), (0x0E81,0x0E83), (0x0E84,0x0E85), (0x0E87,0x0E89), (0x0E8A,0x0E8B), (0x0E8D,0x0E8E), (0x0E94,0x0E98), (0x0E99,0x0EA0), (0x0EA1,0x0EA4), (0x0EA5,0x0EA6), (0x0EA7,0x0EA8), (0x0EAA,0x0EAC), (0x0EAD,0x0EBA), (0x0EBB,0x0EBE), (0x0EC0,0x0EC5), (0x0EC6,0x0EC7), (0x0EC8,0x0ECE), (0x0ED0,0x0EDA), (0x0EDC,0x0EE0), (0x0F00,0x0F01), (0x0F18,0x0F1A), (0x0F20,0x0F2A), (0x0F35,0x0F36), (0x0F37,0x0F38), (0x0F39,0x0F3A), (0x0F3E,0x0F48), (0x0F49,0x0F6D), (0x0F71,0x0F85), (0x0F86,0x0F98), (0x0F99,0x0FBD), (0x0FC6,0x0FC7), (0x1000,0x104A), (0x1050,0x109E), (0x10A0,0x10C6), (0x10C7,0x10C8), (0x10CD,0x10CE), (0x10D0,0x10FB), (0x10FC,0x1249), (0x124A,0x124E), (0x1250,0x1257), (0x1258,0x1259), (0x125A,0x125E), (0x1260,0x1289), (0x128A,0x128E), (0x1290,0x12B1), (0x12B2,0x12B6), (0x12B8,0x12BF), (0x12C0,0x12C1), (0x12C2,0x12C6), (0x12C8,0x12D7), (0x12D8,0x1311), (0x1312,0x1316), (0x1318,0x135B), (0x135D,0x1360), (0x1369,0x1372), (0x1380,0x1390), (0x13A0,0x13F6), (0x13F8,0x13FE), (0x1401,0x166D), (0x166F,0x1680), (0x1681,0x169B), (0x16A0,0x16EB), (0x16EE,0x16F9), (0x1700,0x170D), (0x170E,0x1715), (0x1720,0x1735), (0x1740,0x1754), (0x1760,0x176D), (0x176E,0x1771), (0x1772,0x1774), (0x1780,0x17D4), (0x17D7,0x17D8), (0x17DC,0x17DE), (0x17E0,0x17EA), (0x180B,0x180E), (0x1810,0x181A), (0x1820,0x1878), (0x1880,0x18AB), (0x18B0,0x18F6), (0x1900,0x191F), (0x1920,0x192C), (0x1930,0x193C), (0x1946,0x196E), (0x1970,0x1975), (0x1980,0x19AC), (0x19B0,0x19CA), (0x19D0,0x19DB), (0x1A00,0x1A1C), (0x1A20,0x1A5F), (0x1A60,0x1A7D), (0x1A7F,0x1A8A), (0x1A90,0x1A9A), (0x1AA7,0x1AA8), (0x1AB0,0x1ABE), (0x1B00,0x1B4C), (0x1B50,0x1B5A), (0x1B6B,0x1B74), (0x1B80,0x1BF4), (0x1C00,0x1C38), (0x1C40,0x1C4A), (0x1C4D,0x1C7E), (0x1CD0,0x1CD3), (0x1CD4,0x1CF7), (0x1CF8,0x1CFA), (0x1D00,0x1DF6), (0x1DFC,0x1F16), (0x1F18,0x1F1E), (0x1F20,0x1F46), (0x1F48,0x1F4E), (0x1F50,0x1F58), (0x1F59,0x1F5A), (0x1F5B,0x1F5C), (0x1F5D,0x1F5E), (0x1F5F,0x1F7E), (0x1F80,0x1FB5), (0x1FB6,0x1FBD), (0x1FBE,0x1FBF), (0x1FC2,0x1FC5), (0x1FC6,0x1FCD), (0x1FD0,0x1FD4), (0x1FD6,0x1FDC), (0x1FE0,0x1FED), (0x1FF2,0x1FF5), (0x1FF6,0x1FFD), (0x203F,0x2041), (0x2054,0x2055), (0x2071,0x2072), (0x207F,0x2080), (0x2090,0x209D), (0x20D0,0x20DD), (0x20E1,0x20E2), (0x20E5,0x20F1), (0x2102,0x2103), (0x2107,0x2108), (0x210A,0x2114), (0x2115,0x2116), (0x2118,0x211E), (0x2124,0x2125), (0x2126,0x2127), (0x2128,0x2129), (0x212A,0x213A), (0x213C,0x2140), (0x2145,0x214A), (0x214E,0x214F), (0x2160,0x2189), (0x2C00,0x2C2F), (0x2C30,0x2C5F), (0x2C60,0x2CE5), (0x2CEB,0x2CF4), (0x2D00,0x2D26), (0x2D27,0x2D28), (0x2D2D,0x2D2E), (0x2D30,0x2D68), (0x2D6F,0x2D70), (0x2D7F,0x2D97), (0x2DA0,0x2DA7), (0x2DA8,0x2DAF), (0x2DB0,0x2DB7), (0x2DB8,0x2DBF), (0x2DC0,0x2DC7), (0x2DC8,0x2DCF), (0x2DD0,0x2DD7), (0x2DD8,0x2DDF), (0x2DE0,0x2E00), (0x3005,0x3008), (0x3021,0x3030), (0x3031,0x3036), (0x3038,0x303D), (0x3041,0x3097), (0x3099,0x30A0), (0x30A1,0x30FB), (0x30FC,0x3100), (0x3105,0x312E), (0x3131,0x318F), (0x31A0,0x31BB), (0x31F0,0x3200), (0x3400,0x4DB6), (0x4E00,0x9FD6), (0xA000,0xA48D), (0xA4D0,0xA4FE), (0xA500,0xA60D), (0xA610,0xA62C), (0xA640,0xA670), (0xA674,0xA67E), (0xA67F,0xA6F2), (0xA717,0xA720), (0xA722,0xA789), (0xA78B,0xA7AE), (0xA7B0,0xA7B8), (0xA7F7,0xA828), (0xA840,0xA874), (0xA880,0xA8C5), (0xA8D0,0xA8DA), (0xA8E0,0xA8F8), (0xA8FB,0xA8FC), (0xA8FD,0xA8FE), (0xA900,0xA92E), (0xA930,0xA954), (0xA960,0xA97D), (0xA980,0xA9C1), (0xA9CF,0xA9DA), (0xA9E0,0xA9FF), (0xAA00,0xAA37), (0xAA40,0xAA4E), (0xAA50,0xAA5A), (0xAA60,0xAA77), (0xAA7A,0xAAC3), (0xAADB,0xAADE), (0xAAE0,0xAAF0), (0xAAF2,0xAAF7), (0xAB01,0xAB07), (0xAB09,0xAB0F), (0xAB11,0xAB17), (0xAB20,0xAB27), (0xAB28,0xAB2F), (0xAB30,0xAB5B), (0xAB5C,0xAB66), (0xAB70,0xABEB), (0xABEC,0xABEE), (0xABF0,0xABFA), (0xAC00,0xD7A4), (0xD7B0,0xD7C7), (0xD7CB,0xD7FC), (0xF900,0xFA6E), (0xFA70,0xFADA), (0xFB00,0xFB07), (0xFB13,0xFB18), (0xFB1D,0xFB29), (0xFB2A,0xFB37), (0xFB38,0xFB3D), (0xFB3E,0xFB3F), (0xFB40,0xFB42), (0xFB43,0xFB45), (0xFB46,0xFBB2), (0xFBD3,0xFD3E), (0xFD50,0xFD90), (0xFD92,0xFDC8), (0xFDF0,0xFDFC), (0xFE00,0xFE10), (0xFE20,0xFE30), (0xFE33,0xFE35), (0xFE4D,0xFE50), (0xFE70,0xFE75), (0xFE76,0xFEFD), (0xFF10,0xFF1A), (0xFF21,0xFF3B), (0xFF3F,0xFF40), (0xFF41,0xFF5B), (0xFF66,0xFFBF), (0xFFC2,0xFFC8), (0xFFCA,0xFFD0), (0xFFD2,0xFFD8), (0xFFDA,0xFFDD), (0x10000,0x1000C), (0x1000D,0x10027), (0x10028,0x1003B), (0x1003C,0x1003E), (0x1003F,0x1004E), (0x10050,0x1005E), (0x10080,0x100FB), (0x10140,0x10175), (0x101FD,0x101FE), (0x10280,0x1029D), (0x102A0,0x102D1), (0x102E0,0x102E1), (0x10300,0x10320), (0x10330,0x1034B), (0x10350,0x1037B), (0x10380,0x1039E), (0x103A0,0x103C4), (0x103C8,0x103D0), (0x103D1,0x103D6), (0x10400,0x1049E), (0x104A0,0x104AA), (0x10500,0x10528), (0x10530,0x10564), (0x10600,0x10737), (0x10740,0x10756), (0x10760,0x10768), (0x10800,0x10806), (0x10808,0x10809), (0x1080A,0x10836), (0x10837,0x10839), (0x1083C,0x1083D), (0x1083F,0x10856), (0x10860,0x10877), (0x10880,0x1089F), (0x108E0,0x108F3), (0x108F4,0x108F6), (0x10900,0x10916), (0x10920,0x1093A), (0x10980,0x109B8), (0x109BE,0x109C0), (0x10A00,0x10A04), (0x10A05,0x10A07), (0x10A0C,0x10A14), (0x10A15,0x10A18), (0x10A19,0x10A34), (0x10A38,0x10A3B), (0x10A3F,0x10A40), (0x10A60,0x10A7D), (0x10A80,0x10A9D), (0x10AC0,0x10AC8), (0x10AC9,0x10AE7), (0x10B00,0x10B36), (0x10B40,0x10B56), (0x10B60,0x10B73), (0x10B80,0x10B92), (0x10C00,0x10C49), (0x10C80,0x10CB3), (0x10CC0,0x10CF3), (0x11000,0x11047), (0x11066,0x11070), (0x1107F,0x110BB), (0x110D0,0x110E9), (0x110F0,0x110FA), (0x11100,0x11135), (0x11136,0x11140), (0x11150,0x11174), (0x11176,0x11177), (0x11180,0x111C5), (0x111CA,0x111CD), (0x111D0,0x111DB), (0x111DC,0x111DD), (0x11200,0x11212), (0x11213,0x11238), (0x11280,0x11287), (0x11288,0x11289), (0x1128A,0x1128E), (0x1128F,0x1129E), (0x1129F,0x112A9), (0x112B0,0x112EB), (0x112F0,0x112FA), (0x11300,0x11304), (0x11305,0x1130D), (0x1130F,0x11311), (0x11313,0x11329), (0x1132A,0x11331), (0x11332,0x11334), (0x11335,0x1133A), (0x1133C,0x11345), (0x11347,0x11349), (0x1134B,0x1134E), (0x11350,0x11351), (0x11357,0x11358), (0x1135D,0x11364), (0x11366,0x1136D), (0x11370,0x11375), (0x11480,0x114C6), (0x114C7,0x114C8), (0x114D0,0x114DA), (0x11580,0x115B6), (0x115B8,0x115C1), (0x115D8,0x115DE), (0x11600,0x11641), (0x11644,0x11645), (0x11650,0x1165A), (0x11680,0x116B8), (0x116C0,0x116CA), (0x11700,0x1171A), (0x1171D,0x1172C), (0x11730,0x1173A), (0x118A0,0x118EA), (0x118FF,0x11900), (0x11AC0,0x11AF9), (0x12000,0x1239A), (0x12400,0x1246F), (0x12480,0x12544), (0x13000,0x1342F), (0x14400,0x14647), (0x16800,0x16A39), (0x16A40,0x16A5F), (0x16A60,0x16A6A), (0x16AD0,0x16AEE), (0x16AF0,0x16AF5), (0x16B00,0x16B37), (0x16B40,0x16B44), (0x16B50,0x16B5A), (0x16B63,0x16B78), (0x16B7D,0x16B90), (0x16F00,0x16F45), (0x16F50,0x16F7F), (0x16F8F,0x16FA0), (0x1B000,0x1B002), (0x1BC00,0x1BC6B), (0x1BC70,0x1BC7D), (0x1BC80,0x1BC89), (0x1BC90,0x1BC9A), (0x1BC9D,0x1BC9F), (0x1D165,0x1D16A), (0x1D16D,0x1D173), (0x1D17B,0x1D183), (0x1D185,0x1D18C), (0x1D1AA,0x1D1AE), (0x1D242,0x1D245), (0x1D400,0x1D455), (0x1D456,0x1D49D), (0x1D49E,0x1D4A0), (0x1D4A2,0x1D4A3), (0x1D4A5,0x1D4A7), (0x1D4A9,0x1D4AD), (0x1D4AE,0x1D4BA), (0x1D4BB,0x1D4BC), (0x1D4BD,0x1D4C4), (0x1D4C5,0x1D506), (0x1D507,0x1D50B), (0x1D50D,0x1D515), (0x1D516,0x1D51D), (0x1D51E,0x1D53A), (0x1D53B,0x1D53F), (0x1D540,0x1D545), (0x1D546,0x1D547), (0x1D54A,0x1D551), (0x1D552,0x1D6A6), (0x1D6A8,0x1D6C1), (0x1D6C2,0x1D6DB), (0x1D6DC,0x1D6FB), (0x1D6FC,0x1D715), (0x1D716,0x1D735), (0x1D736,0x1D74F), (0x1D750,0x1D76F), (0x1D770,0x1D789), (0x1D78A,0x1D7A9), (0x1D7AA,0x1D7C3), (0x1D7C4,0x1D7CC), (0x1D7CE,0x1D800), (0x1DA00,0x1DA37), (0x1DA3B,0x1DA6D), (0x1DA75,0x1DA76), (0x1DA84,0x1DA85), (0x1DA9B,0x1DAA0), (0x1DAA1,0x1DAB0), (0x1E800,0x1E8C5), (0x1E8D0,0x1E8D7), (0x1EE00,0x1EE04), (0x1EE05,0x1EE20), (0x1EE21,0x1EE23), (0x1EE24,0x1EE25), (0x1EE27,0x1EE28), (0x1EE29,0x1EE33), (0x1EE34,0x1EE38), (0x1EE39,0x1EE3A), (0x1EE3B,0x1EE3C), (0x1EE42,0x1EE43), (0x1EE47,0x1EE48), (0x1EE49,0x1EE4A), (0x1EE4B,0x1EE4C), (0x1EE4D,0x1EE50), (0x1EE51,0x1EE53), (0x1EE54,0x1EE55), (0x1EE57,0x1EE58), (0x1EE59,0x1EE5A), (0x1EE5B,0x1EE5C), (0x1EE5D,0x1EE5E), (0x1EE5F,0x1EE60), (0x1EE61,0x1EE63), (0x1EE64,0x1EE65), (0x1EE67,0x1EE6B), (0x1EE6C,0x1EE73), (0x1EE74,0x1EE78), (0x1EE79,0x1EE7D), (0x1EE7E,0x1EE7F), (0x1EE80,0x1EE8A), (0x1EE8B,0x1EE9C), (0x1EEA1,0x1EEA4), (0x1EEA5,0x1EEAA), (0x1EEAB,0x1EEBC), (0x20000,0x2A6D7), (0x2A700,0x2B735), (0x2B740,0x2B81E), (0x2B820,0x2CEA2), (0x2F800,0x2FA1E), (0xE0100,0xE01F0)])
def is_identifier_start(character):
    global __id_start

    if len(character) != 1:
        # It is theoretically possible that a character > 0x10000 arrives on a python
        # narrow build.
        error.log("The underlying python build cannot handle character '%s'." % character)

    char_value = ord(character)
    return __id_start.contains(char_value)

def is_identifier_continue(character):
    global __id_continue

    if len(character) != 1:
        # It is theoretically possible that a character > 0x10000 arrives on a python
        # narrow build.
        error.log("The underlying python build cannot handle character '%s'." % character)

    char_value = ord(character)
    return __id_continue.contains(char_value)

def is_identifier(identifier, TolerantF=False):
    if not identifier: return False

    if TolerantF:
        # Do not require 'identifier start'
        if not is_identifier_continue(identifier[0]): return False
    else:
        if not is_identifier_start(identifier[0]): return False

    if len(identifier) == 1: return True

    for letter in identifier[1:]:
        if is_identifier_continue(letter) == False: return False

    return True

def optional_flags(fh, SectionName, Default, AdmissibleDb, BadCombinationList):
    pos = fh.tell()
    if not check(fh, "("): return Default

    flag_txt = read_until_character(fh, ")").strip().replace(" ", "").replace("\t", "").replace("\n", "").replace("\r", "")
    for letter in flag_txt:
        if letter in AdmissibleDb: continue

        fh.seek(pos)
        explanation_txt = [
            "'%s' for %s." % (flag, explanation)
            for flag, explanation in AdmissibleDb.items()
        ]
        explanation_str = "Options are: "\
                          + "\n             ".join(explanation_txt)
        error.log("Flag '%s' not permitted for %s.\n" % (letter, SectionName) + \
                  explanation_str, fh)

    # Bad combination check:
    for bad_combination in BadCombinationList:
        suspect_list = [
            flag for flag in bad_combination if flag in flag_txt
        ]
        if len(suspect_list) > 1:
            suspect_list.sort()
            error.log("Flag '%s' and '%s' cannot be used\n"
                      "at the same time in %s." % (suspect_list[0], suspect_list[1], SectionName), fh)

    return flag_txt

def read_identifier(fh, TolerantF=False, OnMissingStr=None):
    def __read(fh, TolerantF):
        pos = fh.tell()
        txt = fh.read(1)
        if not txt: fh.seek(pos); return ""

        if TolerantF:
            if not is_identifier_continue(txt): fh.seek(pos); return ""
        else:
            if not is_identifier_start(txt): fh.seek(pos); return ""

        while 1 + 1 == 2:
            pos = fh.tell()
            tmp = fh.read(1)
            if not tmp: return txt

            if is_identifier_continue(tmp): txt += tmp
            else:                           fh.seek(pos); return txt

    result = __read(fh, TolerantF)

    if not result and OnMissingStr is not None: 
        error.log(OnMissingStr, fh)
    return result

def find_end_of_identifier(Txt, StartIdx, L):
    for i in range(StartIdx, L):
        if not is_identifier_continue(Txt[i]): return i
    else:
        return L

def parse_identifier_assignment(fh):
    # NOTE: Catching of EOF happens in caller
    check_or_die(fh, "=", " for assignment")

    skip_whitespace(fh)
    identifier = read_identifier(fh)

    check_or_die(fh, ";", " for assignment. Since quex version 0.33.5 this is required.")

    return identifier.strip()

def read_namespaced_name(FileHandle_or_String, Meaning, AllowEmptyF=False, NamespaceAllowedF=True):
    fh = UniStream(FileHandle_or_String)

    # Overstep a starting '::' if present.
    pos = fh.tell()
    if fh.read(2) != "::": fh.seek(pos)

    # Parsing the namespace definition
    try:
        name_list  = [""]   # Signalize Empty by <<name_list[-1] == "">>
        while 1 + 1 == 2:
            skip_whitespace(fh)
            name = read_identifier(fh)
            if not name: break

            name_list[-1] = name
            if not check(fh, "::"): break
            name_list.append("")
    except:
        pass

    # Error Check
    if not name_list[-1]: # Empty, or last name missing?
        if not AllowEmptyF: 
            error.log("Missing identifier in %s name specification." % Meaning, fh)

    if fh.string_f(): 
        pos = fh.tell()
        trailing_chars = fh.read(1)
        if trailing_chars:
            error.log("Inadmissible character '%s' in %s specification." % \
                      (trailing_chars, Meaning), fh)
        fh.seek(pos)

    name       = name_list[-1]
    name_space = name_list[:-1]
    name_safe  = "_".join(name_list)
    if not NamespaceAllowedF and name_space:
        error.log("Output language does not allow namespaces.\n" + \
                  "Name spaces are inadmissible for %s." % Meaning)
        
    return name, name_space, name_safe

def get_text_line_n(Txt, Pos):
    line_n = 1
    for i in range(0, Pos):
        if Txt[i] == "\n": line_n += 1
    return line_n

def delete_comment(Content, Opener, Closer, LeaveNewlineDelimiter=False):
    # delete comment lines in C++ form
    new_content = ""
    prev_i      = 0
    while 1 + 1 == 2:
        i = Content.find(Opener, prev_i)
        if i == -1: 
            new_content += Content[prev_i:]
            break
        new_content += Content[prev_i:i]
        prev_i = i + len(Opener)
        i = Content.find(Closer, prev_i)
        if i == -1: break
        if LeaveNewlineDelimiter:
            new_content += "\n" * Content[prev_i:i+len(Closer)].count("\n")
        prev_i = i + len(Closer)

    return new_content

def get_number_base(fh):
    """Checks on the prefix of a number and determines the number base. When
    this function is done, 'fh' points to the beginning of the number to be
    parsed.

    RETURNS: [0] base
             [1] digits which are available in that codec
    """
    pos = fh.tell()
    decimal_digits = "0123456789"

    first = fh.read(1)
    if not first or not first.isdigit(): 
        fh.seek(pos)
        return None, None
    elif first != "0":
        fh.seek(pos)
        return 10, decimal_digits

    pos2   = fh.tell()
    second = fh.read(1)
    if not second:  
        fh.seek(pos) 
        return 10, decimal_digits
    elif second.isdigit():
        fh.seek(pos2)
        return 10, decimal_digits
    elif second == ".":
        error.log("Decimal integer number cannot contain '.'.", fh)
    elif not second.isalpha():
        fh.seek(pos)
        return 10, decimal_digits

    try:
        return {
            "x": (16,       "0123456789abcdefABCDEF."),  #  '.' is allowed and means nothing
            "o": (8,        "01234567."),                #  '.' is allowed and means nothing
            "b": (2,        "01."),                      #  '.' is allowed and means nothing
            "r": ("roman",  "MCDXLIVmcdxliv"),
            "n": ("Napier", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        }[second]
    except:
        error.log("Number format '0%s' is not supported by quex.\n" % second + \
                  "Use prefix '0x' for hexadecimal numbers.\n" + \
                  "           '0o' for octal numbers.\n"       + \
                  "           '0b' for binary numbers.\n"      + \
                  "           '0r' for roman numbers.\n"      + \
                  "           '0n' for Napier numbers.\n"      + \
                  "           and no prefix for decimal numbers.", fh)

def read_integer(fh):
    postion_0 = fh.tell()

    base, digit_list = get_number_base(fh)
    if base is None: return None

    txt = ""
    while 1 + 1 == 2:
        pos = fh.tell()
        tmp = fh.read(1)
        if   tmp == "": break
        elif tmp not in digit_list: fh.seek(pos); break
        txt += tmp

    # If we drop out on a digit, then let us assume that the user just missed a point
    if tmp.isdigit() or (tmp in list("ABCDEFabcdef")):
        error.log("Digit '%s' cannot be part of an expression of base %s." % (tmp, base), fh)

    txt = txt.replace(".", "")
    if not txt:
        if base in [2, 8, 16, "roman", "Napier"]:
            error.log("Missing digits of number base %s, found '%s'." % (str(base), tmp), fh)
        fh.seek(postion_0)
        return None

    # Octal, decimal, and hexadecimal numbers
    if   base in [2, 8, 10, 16]: return int(txt, base)
    elif base == "roman":        return __roman_number(txt, fh)
    elif base == "Napier":       return __napier_number(txt, fh)
    else:                        return __binary_number(txt, fh)

def __binary_number(Text, fh):
    result = 0
    for letter in Text:
        result <<= 1
        if letter == "1": result |= 1
    return result

def __roman_number(Text, fh):
    """Source: http://code.activestate.com -- Code Recipes 
               Recipe 81611 by Paul Winkler.
    """
    input = Text.upper() 
    # map of (numeral, value, maxcount) tuples
    roman_numeral_map = (('M',  1000, None), ('CM', 900, 1),
                         ('D',  500, 1),     ('CD', 400, 1),
                         ('C',  100, 3),     ('XC', 90, 1),
                         ('L',  50, 1),      ('XL', 40, 1),
                         ('X',  10, 3),      ('IX', 9, 1),
                         ('V',  5, 1),       ('IV', 4, 1), 
                         ('I',  1, 3))

    result, index = 0, 0
    for numeral, value, maxcount in roman_numeral_map:
        count = 0
        while input[index: index + len(numeral)] == numeral:
            count += 1 # how many of this numeral we have
            if maxcount is not None and count > maxcount:
                error.log("input 0r%s is not a valid roman numeral." % Text, fh)
            result += value
            index  += len(numeral)

    if index < len(input): # There are characters unaccounted for.
        error.log("input 0r%s is not a valid roman numeral." % Text, fh)

    return result

def __napier_number(Text, fh):
    def value(C): 
        Cv = ord(C)
        if Cv >= ord('a') and Cv <= ord('z'):
            return Cv - ord('a')
        elif Cv >= ord('A') and Cv <= ord('Z'):
            return Cv - ord('A')
        else:
            # Before this function is called, it must be safe to assume that 
            # the text contains a valid Napier number.
            assert False

    return sum(2**value(c) for c in Text)

def extract_identifiers_with_specific_prefix(Content, Prefix):
    L = len(Content)
    i = 0
    finding_list = []
    while 1 + 1 == 2:
        i = Content.find(Prefix, i)
        # not found?
        if i == -1: break
        # is it inside an identifier?
        if i != 0 and is_identifier_start(Content[i-1]): i += 1; continue
        end_i = find_end_of_identifier(Content, i, L)
        finding_list.append([Content[i:end_i], get_text_line_n(Content, i)])
        i = end_i
    return finding_list

def read_until_whitespace(fh):
    txt = ""
    previous_tmp = ""
    previous_pos = 0
    while 1 + 1 == 2:
        pos = fh.tell()
        tmp = fh.read(1)
        if not tmp: 
            if not txt: raise EndOfStreamException()
            else:       return txt

        elif tmp.isspace():                                fh.seek(pos); return txt
        elif previous_tmp == "/" and (tmp in ["*",  "/"]): fh.seek(previous_pos); return txt[:-1]
        txt += tmp
        previous_tmp = tmp
        previous_pos = pos

def snap_until(stream, ClosingDelimiter, OpeningDelimiter=None):
     """Cuts the first letters of the utf8_string until an un-backslashed
        Delimiter occurs.

     TODO: may be this function can be replaced by the following.
     """
     cut_string = ""  
     backslash_f = False
     open_bracket_n = 1 
     while 1 + 1 == 2:
        letter = stream.read(1)
        if letter == "": 
            raise error.log("Unable to find closing delimiter '%s'" % ClosingDelimiter, stream)

        cut_string += letter    

        if letter == "\\": 
            backslash_f = not backslash_f       
            continue
            
        elif letter == ClosingDelimiter and not backslash_f: 
            if open_bracket_n == 1: cut_string = cut_string[:-1]; break
            open_bracket_n -= 1

        elif letter == OpeningDelimiter and not backslash_f: 
            # NOTE: if OpeningDelimiter is None, then this can never be the case!
            open_bracket_n += 1

        # if a backslash would have appeared, we would have 'continue'd (see above)
        backslash_f = False    
     else:
        raise error.log("Unable to find closing delimiter '%s'" % ClosingDelimiter, stream)
   
     return cut_string

def read_until_closing_bracket(fh, Opener, Closer,
                               IgnoreRegions = [ ['"', '"'],      # strings
                                                 ['\'', '\''],    # characters
                                                 ["//", "\n"],    # c++ comments
                                                 ["/*", "*/"] ],  # c comments
                               SkipClosingDelimiterF = True):                    
    """This function does not eat the closing bracket from the stream.
    """                                                             
    open_brackets_n = 1
    backslash_f     = False
    txt     = ""
    CacheSz = max(len(Opener), len(Closer))
    if len(IgnoreRegions) != 0: 
        # check for correct type, because this can cause terrible errors
        assert type(IgnoreRegions) == list

        for element in IgnoreRegions:                                    
            assert type(element) == list
                                                 
        CacheSz = max([len(delimiter[0]) for delimiter in IgnoreRegions] + [ CacheSz ])

    cache = ["\0"] * CacheSz

    def match_against_cache(cache, Delimiter):
        verdict = __match_against_cache(cache, Delimiter)
        return verdict

    def __match_against_cache(cache, Delimiter):
        """Determine whether the string 'Delimiter' is flood into the cache or not."""
        assert len(Delimiter) <= len(cache), \
               "error: read_until_closing_bracket() cache smaller than delimiter"

        # delimiter == "" means that it is, in fact, not a delimiter (disabled)    
        if not Delimiter: 
            return False
        else:
            L = len(Delimiter)
            for i, letter in enumerate(Delimiter):
                if letter != cache[L-i-1]: return False
            return True

    # ignore_start_triggers = map(lamda x: x[0], IgnoreRegions)
    while 1 + 1 == 2:
        tmp = fh.read(1)
        txt += tmp
        cache.insert(0, tmp)  # element 0 last element flood into cache (current)
        cache.pop(-1)         # element N first element                 (oldest)

        if not tmp:         
            raise EndOfStreamException()

        elif tmp == "\\":       
            backslash_f = not backslash_f   # every second backslash switches to 'non-escape char'
            continue

        if not backslash_f:
            if   match_against_cache(cache, Opener):
                open_brackets_n += 1
            elif match_against_cache(cache, Closer):
                open_brackets_n -= 1
                if open_brackets_n == 0: 
                    # stop accumulating text when the closing delimiter is reached. do not 
                    # append the closing delimiter to the text. 
                    txt = txt[:-len(Closer)]
                    break

        backslash_f = False

        for delimiter in IgnoreRegions:
            # If the start delimiter for ignored regions matches the strings recently in flooded into
            # the cache, then read until the end of the region that is to be ignored.
            if match_against_cache(cache, delimiter[0]): 
                position = fh.tell()
                try:
                    txt += read_until_closing_bracket(fh, "", delimiter[1], IgnoreRegions=[]) 
                except:
                    fh.seek(position)
                    error.log("Unbalanced '%s', reached end of file before closing '%s' was found." % \
                              (delimiter[0].replace("\n", "\\n"), delimiter[1].replace("\n", "\\n")), 
                              fh)

                txt += delimiter[1]
                # the 'ignore region info' may contain information about with what the
                # closing delimiter is to be replaced
                # flush the cache
                cache = ["\0"] * CacheSz
                break
                
    return txt

def read_until_character(fh, Character):
    """Backslash may disable terminating character."""
    backslash_n = 0
    txt         = ""

    # ignore_start_triggers = map(lamda x: x[0], IgnoreRegions)
    # TODO: incorporate "comment ignoring"
    while 1 + 1 == 2:
        tmp = fh.read(1)
        if   tmp == "": raise EndOfStreamException()
        elif tmp == "\\": backslash_n += 1
        else:
            backslash_n = 0
            if backslash_n % 2 != 1:
                if tmp == Character:
                    return txt
        txt += tmp

    return txt

def read_until_letter(fh, EndMarkers, Verbose=False):
    txt = ""
    while 1 + 1 == 2:
        pos = fh.tell()
        tmp = fh.read(1)
        if tmp == "":   
            if Verbose: return "", -1, pos
            else:       return ""

        if tmp in EndMarkers:
            if Verbose: return txt, EndMarkers.index(tmp), pos
            else:       return txt
        txt += tmp

def clean_up():
    # -- delete temporary files
    for file in temporary_files:
        os.system("rm %s" % file)

def check_whitespace(fh):
    pos = fh.tell()
    skip_whitespace(fh)
    if pos == fh.tell(): return False
    else:                return True

def check_or_die(fh, What, Comment = "."):
    if not check(fh, What):
        error.log("Missing '%s'" % What + Comment, fh)

def check(fh, Word, SkipWhitespaceExceptNewlineF=False):
    position = fh.tell()
    try:
        skip_whitespace(fh, SkipWhitespaceExceptNewlineF)
        dummy = fh.read(len(Word))
        if dummy == Word: return True
    except EndOfStreamException:
        pass
    fh.seek(position)
    return False

def check_end_of_file(fh):
    position = fh.tell()
    if not fh.read(1): return True
    fh.seek(position)
    return False

def get_integer_parameter_value(MemberName, ValueStr):
    if type(ValueStr) == int: 
        return ValueStr
    result = read_integer(UniStream(ValueStr))
    if result is None:
        error.log("Cannot convert '%s' into an integer for '%s'.\n" % (ValueStr, MemberName) + \
                  "Use prefix '0x' for hexadecimal numbers.\n" + \
                  "           '0o' for octal numbers.\n"       + \
                  "           '0b' for binary numbers.\n"      + \
                  "           '0r' for roman numbers.\n"      + \
                  "           and no prefix for decimal numbers.")
    return result

